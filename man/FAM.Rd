% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FAM.R
\name{FAM}
\alias{FAM}
\title{Functional Additive Models}
\usage{
FAM(Y, Lx, Lt, K = "epan", FVE = NULL, xi = NULL, h = NULL)
}
\arguments{
\item{Y}{An \emph{n}-dimensional vector whose elements consist of scalar responses.}

\item{Lx}{A list of \emph{n} vectors containing the observed values for each individual. See \code{FPCA} for detail.}

\item{Lt}{A list of \emph{n} vectors containing the observation time points for each individual corresponding to y. Each vector should be sorted in ascending order. See \code{FPCA} for detail.}

\item{K}{A \code{function} object representing the kernel to be used in the smooth backfitting (default is 'epan', the the Epanechnikov kernel).}

\item{FVE}{The fraction of variance explained of of FPCA for each predictor process (default is 0.95).}

\item{xi}{An \emph{N} by \emph{K} matrix whose column vectors consist of \emph{N} vectors of estimation points for each component function.}

\item{h}{A \emph{K}-dimensional vector of bandwidths for kernel smoothing to estimate each component function (default is NULL, but it automatically apply shrinkage factor bandwidth selector. See Han et al. (2016)),}
}
\value{
A list containing the following fields:
\item{mu}{Mean estimator of \eqn{EY}}
\item{fam}{A \emph{N} by \emph{K} matrix whose column vectors consist of the component function estimators at the given estimation points.}
\item{xi}{An \emph{N} by \emph{K} matrix whose column vectors consist of \emph{N} vectors of estimation points for each component function.}
}
\description{
Functional additive models with multiple predictor processes
}
\details{
\code{FAM} fits functional additive models for a scalar response and single predictor process proposed by Mueller and Yao (2007) that \deqn{E(Y | \mathbf{X}) = \sum_{k=1}^K g_{k}(\xi_{k}),} where \eqn{\xi_{k}} stand for the k-th FPC score of the the predictor process.
}
\examples{

set.seed(1000)

library(MASS)

f1 <- function(t) t
f2 <- function(t) 2*cos(2*pi*t/4)
f3 <- function(t) 1.5*sin(2*pi*t/4)
f4 <- function(t) 1.5*atan(2*pi*t/4)

n<-1000

sig <- diag(c(4.0,2.0,1.5,1.2))

scoreX <- mvrnorm(n,mu=rep(0,4),Sigma=sig)
Y <- f1(scoreX[,1]) + f2(scoreX[,2]) + f3(scoreX[,3]) + f4(scoreX[,4]) + rnorm(n,0,0.5)

phi1 <- function(t) sqrt(2)*sin(2*pi*t)
phi2 <- function(t) sqrt(2)*sin(4*pi*t)
phi3 <- function(t) sqrt(2)*cos(2*pi*t)
phi4 <- function(t) sqrt(2)*cos(4*pi*t)

grid <- seq(0,1,length.out=51)
Lt <- Lx <- list()
for (i in 1:n) {
 Lt[[i]] <- grid
 Lx[[i]] <- scoreX[i,1]*phi1(grid) + scoreX[i,2]*phi2(grid) + scoreX[i,3]*phi3(grid) + scoreX[i,4]*phi4(grid)
}

N <- 101
xi <- matrix(rep(seq(-2,2,length.out=N),4),nrow=N,ncol=4)
fit <- FAM(Y=Y,Lx=Lx,Lt=Lt,xi=xi)

par(mfrow=c(2,2))
j <- 1
g1 <- f1(sort(xi[,j])) - trapzRcpp(sort(xi[,j]),f1(sort(xi[,j]))*dnorm(sort(xi[,j]),0,sqrt(sig[j,j])))
tmpSgn <- sign(sum(g1*fit$fam[,j]))
plot(sort(xi[,j]),g1,type='l',col=2,ylim=c(-2.5,2.5),xlab='xi1')
points(sort(xi[,j]),tmpSgn*fit$fam[order(xi[,j]),j],type='l')

j <- 2
g2 <- f2(sort(xi[,j])) - trapzRcpp(sort(xi[,j]),f2(sort(xi[,j]))*dnorm(sort(xi[,j]),0,sqrt(sig[j,j])))
tmpSgn <- sign(sum(g2*fit$fam[,j]))
plot(sort(xi[,j]),g2,type='l',col=2,ylim=c(-2.5,2.5),xlab='xi2')
points(sort(xi[,j]),tmpSgn*fit$fam[order(xi[,j]),j],type='l')

j <- 3
g3 <- f3(sort(xi[,j])) - trapzRcpp(sort(xi[,j]),f3(sort(xi[,j]))*dnorm(sort(xi[,j]),0,sqrt(sig[j,j])))
tmpSgn <- sign(sum(g3*fit$fam[,j]))
plot(sort(xi[,j]),g3,type='l',col=2,ylim=c(-2.5,2.5),xlab='xi3')
points(sort(xi[,j]),tmpSgn*fit$fam[order(xi[,j]),j],type='l')

j <- 4
g4 <- f4(sort(xi[,j])) - trapzRcpp(sort(xi[,j]),f4(sort(xi[,j]))*dnorm(sort(xi[,j]),0,sqrt(sig[j,j])))
tmpSgn <- sign(sum(g4*fit$fam[,j]))
plot(sort(xi[,j]),g4,type='l',col=2,ylim=c(-2.5,2.5),xlab='xi4')
points(sort(xi[,j]),tmpSgn*fit$fam[order(xi[,j]),j],type='l')


}
\references{
\cite{Mueller, H.-G. and Yao, F. (2005), "Functional additive models", JASA, Vol.103, No.484, p.1534-1544.}
}
